use {TxPacket, WriteOut};
use ethernet::{EthernetAddress, EthernetHeader};
use ipv4::{Ipv4Address, Ipv4Header};
use udp::UdpHeader;

pub fn new_discover_msg(mac: EthernetAddress) -> EthernetHeader<Ipv4Header<UdpHeader<DhcpHeader>>> {
    let dhcp_discover = DhcpHeader {
        mac: mac,
        transaction_id: 0xcafebabe,
        type_: DhcpType::Discover,
    };
    let udp = UdpHeader::new(dhcp_discover);
    let ip = Ipv4Header::new(Ipv4Address::new(0, 0, 0, 0),
                             Ipv4Address::new(255, 255, 255, 255),
                             udp);
    EthernetHeader::new(mac, EthernetAddress::new([0xff; 6]), ip)
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct DhcpHeader {
    mac: EthernetAddress,
    transaction_id: u32,
    type_: DhcpType,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum DhcpType {
    Discover,
    Request {
        ip: Ipv4Address,
        dhcp_server_ip: Ipv4Address,
    },
}

impl WriteOut for DhcpHeader {
    fn len(&self) -> usize {
        240 +
        match self.type_ {
            DhcpType::Discover => 10,
            DhcpType::Request { .. } => 16,
        }
    }

    fn write_out(&self, packet: &mut TxPacket) -> Result<(), ()> {
        let operation = match self.type_ {
            DhcpType::Discover |
            DhcpType::Request { .. } => 1,
        };

        packet.push_byte(operation)?;
        packet.push_byte(1)?; // hardware type (1 == ethernet)
        packet.push_byte(6)?; // hardware address len
        packet.push_byte(0)?; // hops

        packet.push_u32(self.transaction_id)?;
        packet.push_u16(0)?; // seconds since start
        packet.push_u16(1 << 15)?; // flags (bit 15 == reply as broadcast)

        let zero_ip = &Ipv4Address::new(0, 0, 0, 0).as_bytes();

        packet.push_bytes(zero_ip)?; // client ip
        packet.push_bytes(zero_ip)?; // own ip
        packet.push_bytes(zero_ip)?; // server ip
        packet.push_bytes(zero_ip)?; // relay agent ip

        packet.push_bytes(&self.mac.as_bytes())?; // client mac
        packet.push_bytes(&[0; 10])?; // client mac padding

        packet.push_bytes(&[0; 64])?; // server name
        packet.push_bytes(&[0; 128])?; // file name
        packet.push_u32(0x63825363)?; // magic cookie

        // options
        match self.type_ {
            DhcpType::Discover => {
                // DHCP message type
                packet.push_byte(53)?; // code
                packet.push_byte(1)?; // len
                packet.push_byte(1)?; // 1 == DHCP Discover

                // parameter request list
                packet.push_byte(55)?; // code
                packet.push_byte(4)?; // len
                packet.push_byte(1)?; // request subnet mask
                packet.push_byte(3)?; // router
                packet.push_byte(15)?; // domain name
                packet.push_byte(6)?; // domain name server

                packet.push_byte(255)?; // option end
            }
            DhcpType::Request { ip, dhcp_server_ip } => {
                // DHCP message type
                packet.push_byte(53)?; // code
                packet.push_byte(1)?; // len
                packet.push_byte(3)?; // 3 == DHCP Request

                // requested ip
                packet.push_byte(50)?; // code
                packet.push_byte(4)?; // len
                packet.push_bytes(&ip.as_bytes())?; // requested ip

                // dhcp server ip
                packet.push_byte(54)?; // code
                packet.push_byte(4)?; // len
                packet.push_bytes(&dhcp_server_ip.as_bytes())?; // dhcp server ip

                packet.push_byte(255)?; // option end
            }
        }

        Ok(())
    }
}

#[test]
fn test_discover() {
    let discover = DhcpHeader {
        mac: EthernetAddress::new([0x00, 0x08, 0xdc, 0xab, 0xcd, 0xef]),
        transaction_id: 0xcafebabe,
        type_: DhcpType::Discover,
    };

    let mut packet = TxPacket::new(discover.len());
    discover.write_out(&mut packet).unwrap();

    let data = packet.0.as_slice();
    let reference_data =
        &[0x01, 0x01, 0x06, 0x00, 0xca, 0xfe, 0xba, 0xbe, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00,
          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
          0x00, 0x08, 0xdc, 0xab, 0xcd, 0xef, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x63, 0x82,
          0x53, 0x63, 0x35, 0x01, 0x01, 0x37, 0x04, 0x01, 0x03, 0x0f, 0x06, 0xff];

    assert_eq!(data.len(), reference_data.len());
    for i in 0..data.len() {
        assert_eq!(data[i], reference_data[i], "{}", i);
    }
}

#[test]
fn test_request() {
    let request = DhcpHeader {
        mac: EthernetAddress::new([0x00, 0x08, 0xdc, 0xab, 0xcd, 0xef]),
        transaction_id: 0xcafebabe,
        type_: DhcpType::Request {
            ip: Ipv4Address::new(141, 52, 46, 201),
            dhcp_server_ip: Ipv4Address::new(141, 52, 46, 13),
        },
    };

    let mut packet = TxPacket::new(request.len());
    request.write_out(&mut packet).unwrap();

    let data = packet.0.as_slice();
    let reference_data =
        &[0x01, 0x01, 0x06, 0x00, 0xca, 0xfe, 0xba, 0xbe, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00,
          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
          0x00, 0x08, 0xdc, 0xab, 0xcd, 0xef, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x63, 0x82,
          0x53, 0x63, 0x35, 0x01, 0x03, 0x32, 0x04, 0x8d, 0x34, 0x2e, 0xc9, 0x36, 0x04, 0x8d,
          0x34, 0x2e, 0x0d, 0xff];

    assert_eq!(data.len(), reference_data.len());
    for i in 0..data.len() {
        assert_eq!(data[i], reference_data[i], "{}", i);
    }
}


#[test]
fn test_discover_packet() {
    let discover = new_discover_msg(EthernetAddress::new([0x00, 0x08, 0xdc, 0xab, 0xcd, 0xef]));
    let mut packet = TxPacket::new(discover.len());
    discover.write_out(&mut packet).unwrap();

    let data = packet.0.as_slice();
    let reference_data =
        &[0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x08, 0xdc, 0xab, 0xcd, 0xef, 0x08, 0x00,
          0x45, 0x00, 0x01, 0x16, 0x00, 0x00, 0x40, 0x00, 0x40, 0x11, 0x39, 0xd8, 0x00, 0x00,
          0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0x00, 0x44, 0x00, 0x43, 0x01, 0x02, 0x4a, 0xd4,
          0x01, 0x01, 0x06, 0x00, 0xca, 0xfe, 0xba, 0xbe, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00,
          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
          0x00, 0x08, 0xdc, 0xab, 0xcd, 0xef, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x63, 0x82,
          0x53, 0x63, 0x35, 0x01, 0x01, 0x37, 0x04, 0x01, 0x03, 0x0f, 0x06, 0xff];

    assert_eq!(data.len(), reference_data.len());
    for i in 0..data.len() {
        assert_eq!(data[i], reference_data[i], "{}", i);
    }
}
